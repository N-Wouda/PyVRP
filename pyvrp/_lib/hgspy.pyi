from typing import Any, Callable, List, Tuple, overload

class GeneticAlgorithm:
    @overload
    def __init__(
        self,
        data: ProblemData,
        penalty_manager: PenaltyManager,
        rng: XorShift128,
        population: Population,
        local_search: LocalSearch,
        crossover_operator: Callable[
            [
                Tuple[Individual, Individual],
                ProblemData,
                PenaltyManager,
                XorShift128,
            ],
            Individual,
        ],
        params: GeneticAlgorithmParams,
    ) -> None: ...
    @overload
    def __init__(
        self,
        data: ProblemData,
        penalty_manager: PenaltyManager,
        rng: XorShift128,
        population: Population,
        local_search: LocalSearch,
        crossover_operator: Callable[
            [
                Tuple[Individual, Individual],
                ProblemData,
                PenaltyManager,
                XorShift128,
            ],
            Individual,
        ],
    ) -> None: ...
    def run(self, stop: StoppingCriterion) -> Result: ...  # type: ignore

class GeneticAlgorithmParams:
    def __init__(
        self,
        nb_penalty_management: int = ...,
        repair_probability: int = ...,
        collect_statistics: bool = ...,
        should_intensify: bool = ...,
    ) -> None: ...
    @property
    def collect_statistics(self) -> bool: ...
    @property
    def nb_penalty_management(self) -> int: ...
    @property
    def repair_probability(self) -> int: ...
    @property
    def should_intensify(self) -> bool: ...

class Individual:
    @overload
    def __init__(
        self,
        data: ProblemData,
        penalty_manager: PenaltyManager,
        rng: XorShift128,
    ) -> None: ...
    @overload
    def __init__(
        self,
        data: ProblemData,
        penalty_manager: PenaltyManager,
        routes: List[List[int]],
    ) -> None: ...
    def cost(self) -> int: ...
    def get_neighbours(self) -> List[Tuple[int, int]]: ...
    def get_routes(self) -> List[List[int]]: ...
    def has_excess_capacity(self) -> bool: ...
    def has_time_warp(self) -> bool: ...
    def is_feasible(self) -> bool: ...
    def to_file(self, arg0: str, arg1: float) -> None: ...

class LocalSearch:
    @overload
    def __init__(
        self,
        data: ProblemData,
        penalty_manager: PenaltyManager,
        rng: XorShift128,
        params: LocalSearchParams,
    ) -> None: ...
    @overload
    def __init__(
        self,
        data: ProblemData,
        penalty_manager: PenaltyManager,
        rng: XorShift128,
    ) -> None: ...
    def add_node_operator(self, op) -> None: ...
    def add_route_operator(self, op) -> None: ...
    def intensify(self, indiv: Individual) -> None: ...
    def search(self, indiv: Individual) -> None: ...

class LocalSearchParams:
    def __init__(
        self,
        weight_wait_time: int = ...,
        weight_time_warp: int = ...,
        nb_granular: int = ...,
        post_process_path_length: int = ...,
    ) -> None: ...
    @property
    def nb_granular(self) -> int: ...
    @property
    def post_process_path_length(self) -> int: ...
    @property
    def weight_time_warp(self) -> int: ...
    @property
    def weight_wait_time(self) -> int: ...

class PenaltyManager:
    @overload
    def __init__(
        self, vehicle_capacity: int, params: PenaltyParams
    ) -> None: ...
    @overload
    def __init__(self, vehicle_capacity: int) -> None: ...

class PenaltyParams:
    def __init__(
        self,
        init_capacity_penalty: int = ...,
        init_time_warp_penalty: int = ...,
        repair_booster: int = ...,
        penalty_increase: float = ...,
        penalty_decrease: float = ...,
        target_feasible: float = ...,
    ) -> None: ...
    @property
    def init_capacity_penalty(self) -> int: ...
    @property
    def init_time_warp_penalty(self) -> int: ...
    @property
    def penalty_decrease(self) -> float: ...
    @property
    def penalty_increase(self) -> float: ...
    @property
    def repair_booster(self) -> int: ...
    @property
    def target_feasible(self) -> float: ...

class Population:
    @overload
    def __init__(
        self,
        data: ProblemData,
        penalty_manager: PenaltyManager,
        rng: XorShift128,
        op: Callable[[ProblemData, Individual, Individual], float],
        params: PopulationParams,
    ) -> None: ...
    @overload
    def __init__(
        self,
        data: ProblemData,
        penalty_manager: PenaltyManager,
        rng: XorShift128,
        op: Callable[[ProblemData, Individual, Individual], float],
    ) -> None: ...
    def add(self, individual: Individual) -> None: ...

class PopulationParams:
    def __init__(
        self,
        min_pop_size: int = ...,
        generation_size: int = ...,
        nb_elite: int = ...,
        nb_close: int = ...,
        lb_diversity: float = ...,
        ub_diversity: float = ...,
    ) -> None: ...
    @property
    def generation_size(self) -> int: ...
    @property
    def lb_diversity(self) -> float: ...
    @property
    def min_pop_size(self) -> int: ...
    @property
    def nb_close(self) -> int: ...
    @property
    def nb_elite(self) -> int: ...
    @property
    def ub_diversity(self) -> float: ...

class ProblemData:
    def __init__(
        self,
        coords: List[Tuple[int, int]],
        demands: List[int],
        nb_vehicles: int,
        vehicle_cap: int,
        time_windows: List[Tuple[int, int]],
        service_durations: List[int],
        duration_matrix: List[List[int]],
        release_times: List[int],
    ) -> None: ...
    def client(self, *args, **kwargs) -> Any: ...
    def depot(self, *args, **kwargs) -> Any: ...
    def dist(self, arg0: int, arg1: int) -> int: ...
    def distance_matrix(self, *args, **kwargs) -> Any: ...
    def from_file(self, *args, **kwargs) -> Any: ...
    def num_clients(self) -> int: ...
    def num_vehicles(self) -> int: ...
    def vehicle_capacity(self) -> int: ...

class Result:
    def __init__(self, *args, **kwargs) -> None: ...
    def get_best_found(self) -> Individual: ...
    def get_iterations(self) -> int: ...
    def get_run_time(self) -> float: ...
    def get_statistics(self) -> Statistics: ...

class Statistics:
    def __init__(self, *args, **kwargs) -> None: ...
    def feas_avg_cost(self) -> List[int]: ...
    def feas_avg_num_routes(self) -> List[float]: ...
    def feas_best_cost(self) -> List[int]: ...
    def feas_pop_size(self) -> List[int]: ...
    def incumbents(self) -> List[Tuple[float, int]]: ...
    def infeas_avg_cost(self) -> List[int]: ...
    def infeas_avg_num_routes(self) -> List[float]: ...
    def infeas_best_cost(self) -> List[int]: ...
    def infeas_pop_size(self) -> List[int]: ...
    def iter_times(self) -> List[float]: ...
    def num_iters(self) -> int: ...
    def run_times(self) -> List[float]: ...
    def to_csv(self, path: str, sep: str = ...) -> None: ...

class XorShift128:
    def __init__(self, seed: int) -> None: ...
    def max(self) -> int: ...
    def min(self) -> int: ...
    def randint(self, high: int) -> int: ...
    def __call__(self) -> int: ...
