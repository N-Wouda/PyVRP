#ifndef PYVRP_CROSSOVER_H
#define PYVRP_CROSSOVER_H

#include "CostEvaluator.h"
#include "ProblemData.h"
#include "Solution.h"
#include "XorShift128.h"

#include <functional>
#include <vector>

namespace crossover
{
/**
 * Greedily inserts each unplanned client into the route that's nearest to the
 * client.
 */
void greedyRepair(std::vector<std::vector<int>> &routes,
                  std::vector<int> const &unplanned,
                  ProblemData const &data,
                  CostEvaluator const &costEvaluator);
}  // namespace crossover

/**
 * Performs two SREX crossovers of the given parents. SREX is a method that
 * selects a set of routes for each parent and replaces the selected routes of
 * the first parent with those of the second parent. The routes are selected by
 * maximizing the overlap between the clients in the two sets of routes. This
 * is achieved through a heuristic that iteratively shifts adjacent routes
 * until no further improvement in maximizing the overlap is observed. Then,
 * two offspring are generated by replacing the selected routes in two distinct
 * ways, and the offspring with the lowest cost is returned.
 *
 * The standard SREX does not take into account vehicle types in the crossover,
 * i.e. the crossover is performed as if there are no vehicle types. Routes in
 * the offspring get assigned the vehicle type of the original route in the
 * parent. Due to the exchange, this may violate the number of available
 * vehicles for a type, which is resolved by greedily reassigning some vehicle
 * types for routes that were exchanged using the first available type.
 *
 * @param parents          The parent solutions.
 * @param data             The problem data.
 * @param costEvaluator    The cost evaluator.
 * @param startIndices     Start indices of routes in parent solutions.
 * @param numMovedRoutes   Number of routes to move.
 * @return A new offspring.
 *
 * <br />
 * Yuichi Nagata and Shigenobu Kobayashi. "A memetic algorithm for
 * the pickup and delivery problem with time windows using selective route
 * exchange crossover". In: International Conference on Parallel Problem Solving
 * from Nature. Springer. 2010, pp. 536â€“545.
 */
Solution selectiveRouteExchange(
    std::pair<Solution const *, Solution const *> const &parents,
    ProblemData const &data,
    CostEvaluator const &costEvaluator,
    std::pair<size_t, size_t> const startIndices,
    size_t const numMovedRoutes);

/**
 * SREX variant that handles heterogeneous vehicle types seperately. This
 * version groups routes by vehicle types and performs the SREX crossover per
 * vehicle type, ensuring exchanges only take place between routes of the same
 * vehicle type. Start indices are optimized per vehicle type as well.
 *
 * Since a single vehicle type may have different sets of customers assigned in
 * both parents, the greedy repair phase is not done per vehicle type but at
 * the end over all routes.
 *
 * @param parents                        The parent solutions.
 * @param data                           The problem data.
 * @param costEvaluator                  The cost evaluator.
 * @param startIndicesPerVehicleType     Start indices per vehicle type.
 * @param numMovedRoutesPerVehicleType   Number of routes to move per type.
 * @return A new offspring.
 */
Solution heterogeneousSelectiveRouteExchange(
    std::pair<Solution const *, Solution const *> const &parents,
    ProblemData const &data,
    CostEvaluator const &costEvaluator,
    std::vector<size_t> const startIndicesPerVehicleType,
    std::vector<size_t> const numMovedRoutesPerVehicleType);

/**
 * Convenience function that performs a route exchange by explicitly specifying
 * which routes should be exchanged. The vector exchanges should have the same
 * length as the first parent, where exchanges[i] = j indicates route i in the
 * first parent should be exchanged with route j from the second parent. If
 * exchanges[i] = -1 the route is not exchanged.
 *
 * @param parents       The parent solutions.
 * @param data          The problem data.
 * @param costEvaluator The cost evaluator.
 * @param exchanges     Vector with exchanges[i] = j indicating exchange, or -1
 */
Solution
routeExchange(std::pair<Solution const *, Solution const *> const &parents,
              ProblemData const &data,
              CostEvaluator const &costEvaluator,
              std::vector<int> const &exchanges);

#endif  // PYVRP_CROSSOVER_H
