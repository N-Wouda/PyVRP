#ifndef CROSSOVER_H
#define CROSSOVER_H

#include "Individual.h"
#include "PenaltyManager.h"
#include "ProblemData.h"
#include "XorShift128.h"

#include <functional>
#include <vector>

namespace crossover
{
/**
 * Greedily inserts the unplanned clients into non-empty routes.
 */
void greedyRepair(std::vector<std::vector<int>> &routes,
                  std::vector<int> const &unplanned,
                  ProblemData const &data);
}  // namespace crossover

/**
 * Performs two SREX crossovers of the given parents. SREX is a method that
 * identifies a set of routes for each parent and replaces the routes of the
 * first parent with those of the second parent. The routes are selected by
 * minimizing the overlap between the two sets of routes. This is achieved
 * through a heuristic that iteratively shifts consecutive routes until no
 * further improvement in the difference is observed. Then, two offspring
 * are generated by exchanging the selected routes in two distinct ways,
 * and the offspring with the lowest cost is returned.
 *
 * @param parents        The parent individuals.
 * @param data           The problem data.
 * @param penaltyManager The penalty manager.
 * @param startA         Start index of consecutive routes in the first parent.
 * @param startB         Start index of consecutive routes in the second parent.
 * @param nMovedRoutes   Number of routes to move.
 * @return The produced offspring.
 *
 * <br /> Yuichi Nagata and Shigenobu Kobayashi. "A memetic algorithm for
 * the pickup and delivery problem with time windows using selective route
 * exchange crossover". In: International Conference on Parallel Problem Solving
 * from Nature. Springer. 2010, pp. 536â€“545.
 */
Individual selectiveRouteExchange(
    std::pair<Individual const *, Individual const *> const &parents,
    ProblemData const &data,
    PenaltyManager const &penaltyManager,
    size_t startA,
    size_t startB,
    size_t const nMovedRoutes);

#endif  // CROSSOVER_H
